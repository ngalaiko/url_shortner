// Code generated by gen_schema_tables.go DO NOT EDIT.

package tables

import (
	"bytes"
	"database/sql"
	"fmt"

	"go.uber.org/zap"

	"github.com/ngalayko/url_shortner/server/dao"
	"github.com/ngalayko/url_shortner/server/schema"
)

// GetUserTokenById returns UserToken from db or cache
func (t *Service) GetUserTokenById(id uint64) (*schema.UserToken, error) {
	return t.GetUserTokenByFields(dao.NewParam(1).Add("id", id))
}

// GetUserTokenByFields returns UserTokens from db or cache
func (t *Service) GetUserTokenByFields(field dao.Param) (*schema.UserToken, error) {
	fields := dao.NewParams(1).Append(field)

	uu, err := t.SelectUserTokensByFields(fields)
	if err != nil {
		return nil, err
	}

	if len(uu) == 0 {
		return nil, sql.ErrNoRows
	}

	return uu[0], nil
}

// SelectUserTokensByFields select many user_token by fields
func (t *Service) SelectUserTokensByFields(fields dao.Params) ([]*schema.UserToken, error) {

	if fields.Len() == 0 {
		return nil, nil
	}

	result := make([]*schema.UserToken, 0, fields.Len())
	missedFields := dao.NewParams(fields.Len())
	for _, f := range fields {

		if value, ok := t.cache.Load(t.user_tokenCacheKey(f["id"])); ok {
			result = append(result, value.(*schema.UserToken))
			continue
		}

		missedFields = append(missedFields, f)
	}

	if missedFields.Len() == 0 {
		return result, nil
	}

	b := bytes.Buffer{}
	b.WriteString("SELECT * " +
		"FROM user_token " +
		"WHERE ")

	i := 1
	values := make([]interface{}, 0, missedFields.Len())
	for fi, missedF := range missedFields {

		if fi > 0 {
			b.WriteString(" OR ")
		}

		b.WriteRune('(')
		j := 0
		for key, value := range missedF {
			values = append(values, value)

			if j > 0 {
				b.WriteString(" AND ")
			}

			b.WriteString(fmt.Sprintf("%s = $%d", key, i))

			i++
			j++
		}
		b.WriteRune(')')
	}

	uu := make([]*schema.UserToken, 0, missedFields.Len())
	if err := t.db.Select(&uu, b.String(), values...); err != nil {
		return nil, err
	}

	for _, u := range uu {
		t.cache.Store(t.user_tokenCacheKey(u.ID), u)
		result = append(result, u)
	}

	return result, nil
}

// InsertUserToken inserts UserToken in db and cache
func (t *Service) InsertUserToken(u *schema.UserToken) error {
	return t.db.Mutate(func(tx *dao.Tx) error {

		insertSQL := "INSERT INTO user_token " +
			"(token, user_id, expired_at) " +
			"VALUES " +
			"($1, $2, $3) " +
			"RETURNING id"

		var id uint64
		if err := tx.Get(&id, insertSQL, u.Token, u.UserID, u.ExpiredAt); err != nil {
			return err
		}
		u.ID = id

		t.logger.Info("UserToken created",
			zap.Reflect("$.Name", u),
		)
		t.cache.Store(t.user_tokenCacheKey(u.ID), u)
		return nil
	})
}

// UpdateUserToken updates UserToken in db and cache
func (t *Service) UpdateUserToken(u *schema.UserToken) error {
	return t.db.Mutate(func(tx *dao.Tx) error {

		updateSQL := "UPDATE user_token " +
			"SET " +
			"token = $1, " +
			"user_id = $2, " +
			"expired_at = $3 " +
			fmt.Sprintf("WHERE id = %d", u.ID)

		_, err := tx.Exec(updateSQL, u.Token, u.UserID, u.ExpiredAt)
		if err != nil {
			return err
		}

		t.logger.Info("UserToken updated",
			zap.Reflect("$.Name", u),
		)
		t.cache.Store(t.user_tokenCacheKey(u.ID), u)
		return nil
	})
}

func (t *Service) user_tokenCacheKey(id interface{}) string {
	b := bytes.Buffer{}
	b.WriteString("user_token")

	b.WriteString(fmt.Sprintf("_id=%v", id))

	return b.String()
}
