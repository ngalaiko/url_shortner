package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"text/template"

	"github.com/ngalayko/url_shortner/server/schema"
)

const (
	idTag        = "id"
	filePath     = "../dao/tables/"
	fileTemplate = `// Code generated by generate_schema_tables.go DO NOT EDIT.

package tables

import (
	"bytes"
	"fmt"

	"github.com/ngalayko/url_shortner/server/dao"
	"github.com/ngalayko/url_shortner/server/logger"
	"github.com/ngalayko/url_shortner/server/schema"
)

type {{ $.Name }}Table struct {
	db     *dao.Db
	logger *logger.Logger
}

func ({{ alias $.Name }}t *{{ $.Name }}Table) Insert{{ $.Name }}({{ alias $.Name }} *schema.{{ $.Name }}) error {
	return {{ alias $.Name }}.db.Mutate(func(tx *dao.Tx) error {

		insertSQL := "INSERT INTO {{ $.TableName }}" +
			"({{ head .DbFields}}{{ range tail .DbFields }}, {{ . }}{{ end }})" +
			"VALUES" +
			fmt.Sprintf("(%v{{ range tail .Fields }}, %v{{ end }})",
				{{ alias $.Name}}.{{ head .Fields }}{{ range tail .Fields }},
				{{ alias $.Name }}.{{ . }}{{ end }})

		_, err := tx.Exec(insertSQL)
		if err != nil {
			return err
		}

		{{ alias $.Name }}t.logger.Info("{{ $.Name }} created",
			zap.Reflect("$.Name", {{ alias $.Name }}),
		)
		return nil
	})
}

func ({{ alias $.Name }}t *{{ $.Name }}Table) Update{{ $.Name }}({{ alias $.Name }} *schema.{{ $.Name }}) error {
	return {{ alias $.Name }}.db.Mutate(func(tx *dao.Tx) error {

		updateSQL := "UPDATE {{ $.TableName }}" +
			"SET" +
			{{ range $index, $element := tail $.Fields }}fmt.Sprintf("{{ index $.DbFields $index }} = %v,", {{ alias $.Name }}.{{ $element }}) +
			{{ end }}fmt.Sprintf("{{ last $.DbFields }} = %v", {{ alias $.Name }}.{{ last $.Fields }})

		_, err := tx.Exec(updateSQL)
		if err != nil {
			return err
		}

		{{ alias $.Name }}t.logger.Info("{{ $.Name }} updated",
			zap.Reflect("$.Name", {{ alias $.Name }}),
		)
		return nil
	})
}
`
)

type templateData struct {
	Name      string
	TableName string
	Fields    []string
	DbFields  []string
}

//go:generate go run generate_schema_tables.go
func main() {

	tables := []struct {
		typ       reflect.Type
		tableName string
	}{
		{reflect.TypeOf(schema.User{}), "users"},
		{reflect.TypeOf(schema.Link{}), "links"},
	}

	for _, table := range tables {
		if err := generate(table.typ, table.tableName); err != nil {
			panic(err)
		}
	}
}

func generate(typ reflect.Type, tableName string) error {

	file, err := os.Create(filePath + tableName + ".go")
	if err != nil {
		return fmt.Errorf("error opening file %s: %s", typ.Name(), err)
	}
	defer file.Close()

	data := templateData{
		Name:      typ.Name(),
		TableName: tableName,
	}

	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)

		dbTag := getTag(field, "db")

		if dbTag == idTag {
			continue
		}

		data.DbFields = append(data.DbFields, dbTag)
		data.Fields = append(data.Fields, field.Name)
	}

	t := template.Must(template.New(typ.Name()).Funcs(getTemplateFuncs()).Parse(fileTemplate))
	if err := t.Execute(file, data); err != nil {
		return fmt.Errorf("error executing template %s: %s", t.Name(), err)
	}

	return nil
}

func getTemplateFuncs() template.FuncMap {
	return template.FuncMap{
		"alias": func(str string) string {
			if len(str) < 1 {
				return ""
			}

			return strings.ToLower(str[:1])
		},
		"head": func(ss []string) string {
			return ss[0]
		},
		"tail": func(ss []string) []string {
			return ss[1:]
		},
		"last": func(ss []string) string {
			return ss[len(ss)-1]
		},
	}
}

func getTag(f reflect.StructField, tagName string) string {
	tag := f.Tag.Get(tagName)

	return strings.Split(tag, ",")[0]
}
